## 什么是数据结构？什么是算法？

- 数据结构就是指一组数据的存储结构。
- 算法就是操作数据的一组方法。
  > 数据结构是为算法服务的，算法要作用在特定的数据结构之上。

## 学习的重点

> 掌握一个数据结构与算法中最重要的概念——复杂度分析

### 10 个数据结构：

数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Tree 树

### 10 个算法：

递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法

### 复杂度分析

- 数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，我们就需要一个考量效率和资源消耗的方法，这就是复杂度分析方法。所以，如果你只掌握了数据结构和算法的特点、用法，但是没有学会复杂度分析，那就相当于只知道操作口诀，而没掌握心法。只有把心法了然于胸，才能做到无招胜有招！

### 为什么需要复杂度分析？

#### 测试结果非常依赖测试环境

- 测试环境中硬件的不同会对测试结果有很大的影响。比如，我们拿同样一段代码，分别用 Intel Core i9 处理器和 Intel Core i3 处理器来运行，不用说，i9 处理器要比 i3 处理器执行的速度快很多。还有，比如原本在这台机器上 a 代码执行的速度比 b 代码要快，等我们换到另一台机器上时，可能会有截然相反的结果。

#### 测试结果受数据规模的影响很大

- 后面我们会讲排序算法，我们先拿它举个例子。对同一个排序算法，待排序数据的有序度不一样，排序的执行时间就会有很大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作，执行时间就会非常短。除此之外，如果测试数据规模太小，测试结果可能无法真实地反应算法的性能。比如，对于小规模的数据排序，插入排序可能反倒会比快速排序要快！
  > 我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。

* 大 O 复杂度表示法

```js
function cal(n) {
  let sum = 0;
  for (let i = 0; i <= n; ++i) {
    sum = sum + i;
  }
  return sum;
}
```

- 所以这段代码总的执行时间就是 (2n+2)\*unit_time。可以看出来，所有代码的执行时间 T(n) 与每行代码的执行次数成正比。

```js
function cal(n) {
  let sum = 0;
  for (let i = 0; i <= n; ++i) {
    // 循环执行了 n 遍
    for (let j = 1; j <= n; ++j) {
      // 循环执行了 n 遍
      sum = sum + i * j;
    }
  }
  return sum;
}
```

- 整段代码总的执行时间 T(n) = (2n2+2n+3)\*unit_time。尽管我们不知道 unit_time 的具体值，但是通过这两段代码执行时间的推导过程，我们可以得到一个非常重要的规律，那就是，所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。

- 规律总结
  > T(n) = O(f(n));

* T(n) 它表示代码执行的时间；
* n 表示数据规模的大小；
* f(n) 表示每行代码执行的次数总和。

- 因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

> 第一个例子中的 T(n) = O(2n+2)，第二个例子中的 T(n) = O(2n2+2n+3)。这就是大 O 时间复杂度表示法。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity），简称时间复杂度。

> 当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n) = O(n)； T(n) = O(n2)。